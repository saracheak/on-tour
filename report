1. How you can break down a large problem instance into one or more smaller instances? Your
answer should include how the solution to the original problem is constructed from the sub-
problems and why this breakdown makes sense.
- breaking down into paths and max score of each vertex so when we come across the vertex again we already know the max score

2. What are the base cases of this problem, and what are their solutions?
- max vertex = 1 / or 2 circles (?)
- if value is already in the hash table

3. What data structure would you use to store the partial solutions to this problem? Justify
your answer.
- hash table
- O(1) if you already have the value stored so its fast

4. Give pseudocode for an algorithm that uses memoization to compute the maximum score.
dp[1…n] 
next[1…n]
visited[1..n]

Function computeMax(i):
	if visited[i]:
		return dp[i]
	visited[i] = true
	maxNeighbor = 0 
	next[i] = null
	
	for each neighbor j of space i:
		if value[j] >  value[i]:
			score = computeMax(j)
			if score > maxNeighbor:
				maxNeighbor = score
				next[i] = j
	dp[i] = points[i] + maxNeighbor
	return dp[i]

Function onTour(n):
	maxScore = 0
	start = 1
	
	for i = 1 to n:
		score = computeMax(i)
		if score > maxScore:
			maxScore = score
			start = i
	path = []
	curr = start
	while curr != null:
		path.append(curr)
		curr = next[curr]
	return (maxSore, path)

5. What is the time complexity of your memoized algorithm?
O(n+m)

6. Give pseudocode for an iterative algorithm for this problem.


7. Describe how you could modify your algorithm to identify the maximum-scoring tour, not
just the maximum possible score.


Bonus Describe (briefly) how you would modify your algorithm to account for adjacent equal values
and wildcards. There is likely no algorithm that is guaranteed to solve this problem in
polynomial time, so just focus on solving the problem correctly rather than quickly
